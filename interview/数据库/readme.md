## 数据库索引
### 什么是索引
  常见索引结构：
    1.二叉搜索树
    2.有序序列
    3.哈希表  直接读取，

  索引几种实现方式的优缺点：
    1.哈希表：键值对的方式存储，只适用于等值查询，无法区间查询，比如Redis(key-value数据库)，
    2.有序序列：可以区间查询，但增加删除记录新能低，需要每次都挪动数据，一般用于静态数据存储，对静态数据做索引
    3.二叉搜索树：要求是每个节点的左子节点小于父节点，右子节点大于父节点，查询效率较高，事件复杂度O(logN)
    
  mysql 索引类型：
    innodb(B+树)
    myisam(B树也叫B-树)
    B树和B+树的区别
      B树：1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
          （2）子节点数：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；
          （3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
          （4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;
          B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;
      B+树：
      B树和B+树的区别：
        1.B+树只有叶子结点会存放数据，B树的每个节点都会存放数据
        2.B+树的叶子节点都会通过链表有序连接，能够很快的实现区间查询
        3.B树可以在非叶子节点结束查找，最好的情况是O(1)，但B+树的事件复杂度是O(logN)
        4.B树插入性能比B+树要高
### 创建索引
  普通索引: create index name on tableName(column)
  唯一索引: Unique : create unique index name on tableName
  组件索引: Primary:  alter table tablename add primary key(column)
  联合索引: create index name on tableName(col1,col2)
  删除索引: drop index idx_name on tablename 

Unicode 编码，国际码
中国 GB2312 GBK

全球统一  UTF-8
mysql 里 UTF8MP4
### 建表
CREATE TABLE IF NOT EXISTS `runoob_tbl`(
   `runoob_id`  INT UNSIGNED  AUTO_INCREMENT,
   `runoob_title`  VARCHAR(100)  NOT NULL,
   `runoob_author`  VARCHAR(40)  NOT NULL,
   `submission_date`  DATE,
   PRIMARY KEY ( `runoob_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8MB4;

在表里插入数据
insert into student(
`name`,`sex`,`age`)
values
('TOM',1,19)

修改表里的数据
update student
SET  `sex` = 0
where  `name`='TOM'

删除表里的数据？
delete from  student where name='TOM'

join
select class,name,point from student as a  join lesson as b on a.lesson=b.id
where age =20 

删除表
DROP table ‘student’ 
删除数据库
DROP database  ‘ECUT’
查询表里的女性有多少个？
select count(*) from student where sex=0

-- join 
INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。
LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。
RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。

## 数据库的三大范式
第一范式：原子性，列不可再分
第二范式：唯一性，每一列都与主键相关
第三范式：独立性，避免字段冗余，不能存在被其他字段推导出的

数据库事务

事务就是要保证一组数据库操作要么全部成功 要么全部失败

不是所有的数据库引擎都支持事务
myisam 不支持事务，InnoDB 支持事务

事务具有四个性质
A 原子性   要么全部成功要么全部失败
C 一致性    确保一个事物执行之前和执行之后必须处于一致的状态
I 隔离性     一个事物在提交之前是否能够被其他事务可见
D 持久性  如果一旦一个事务提交了，那么这个改变就是永久性的

事务隔离级别具有四个：
1. 读未提交：一个事务还没有提交时，其他事物能够看到它做的变更
2. 读提交：  一个事物提交了之后，其他事务才能看到变更
3. 可重复读：一个事务在执行过程中，看到的数据总是跟这个事务在启动时
看到的数据一致
4. 串行化： 事务不可并行执行，后访问的事务必须等前一个事务完成，才能继续执行

事务启动的方式
1. 显示启动事务，begin 启动，commit提交，rollback 回滚
2. 程序会自动提交事务

数据库锁
全局锁     表锁       行锁

全局锁有什么用，对业务有影响，不能做其他操作
对数据库全库备份，这种情况只针对没有事务特性的引擎 比如mysam 
InnoDB怎么做备份？
mysqldump 参数 - single transaction , 导出数据前启动一个事物，拿到一致性视图，
这个过程中，数据库可以正常更新业务不受影响。

表锁：
手动触发 lock tables .... read/write
元数据锁  访问一张表的时候自动触发
分为：读锁： 
          对于读操作，可以加读锁，一旦数据表加上读锁，不能加写锁，可以多个事务加多
个读锁 
          写锁：
          对于写操作，一旦加上了写锁，其他事务无法加上读锁和写锁

行锁
可以锁一行或者多行，InnoDB  基于索引实现的
行锁的特性：并发性比较高，开销大，而且有可能出现死锁。

如果出现死锁怎么办？ 
1. 死锁检测，发现有死锁出现时，主动回滚某一个事务，让其他事务继续运行
2.启动超时机制，一定时间过后 ，所有事务都执行rollback回滚
并发事务带来的问题
    相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，
提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。
但并发事务处理也会带来一些问题，主要包括以下几种情况。

更新丢失（Lost Update）：当两个或多个事务选择同一行，
然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，
就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。
例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，
然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人
员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑
人员不能访问同一文件，则可避免此问题
脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，
这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，
如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，
就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。
不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、
或某些记录已经被删除了！这种现象叫做“不可重复读”。
幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，
却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。

脏读 ：
A事务读取了B事务未提交的数据，如果B事务发生了回滚，那么A事务读取
到的数据就是脏数据
幻读：
同一个事务前后多次读取，但是数据的总量不一样，幻读针对的是 insert delete

不可重复读
A事务在执行的过程中，由于A事务比较大，需要长时间多次读取同一条数据，
读取到的数据不一致，A事务无法读取到之前的数据
针对的是 update操作
